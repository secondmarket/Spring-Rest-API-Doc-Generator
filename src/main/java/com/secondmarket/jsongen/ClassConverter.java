package com.secondmarket.jsongen;

import com.secondmarket.annotatedobject.amethod.AnnotatedMethod;
import org.json.simple.JSONObject;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.*;


/**
 * Created with IntelliJ IDEA.
 * main.User: rdavid
 * Date: 6/19/12
 * Time: 1:21 PM
 * To change this template use File | Settings | File Templates.
 */
public class ClassConverter {

    private static Set<Class> classes = new HashSet<Class>();
    private String location;
    private Class clazz;

    public ClassConverter(Class clazz, String location){
        this.clazz = clazz;
        this.location = location;
    }

    /**
     * Begins the Class to JSON conversion
     */
    public void start() {
        this.generateJSON(clazz);
    }


    /**
     * Recursively generate JSON Documentation for a class and all of its fields.
     * @param clazz
     */
    private void generateJSON(Class clazz) {
        Field[] classFields = getAllFields(clazz);
        searchForClasses(clazz, classFields);
    }

    /**
     * Recursively generate JSON for a Class definition.  Classes in java.*.* packages are
     * ignored.
     * @param clazz the class to analyze
     * @param lof the Field[] containing all of the class' fields
     */
    private void searchForClasses(Class clazz, Field[] lof){
        JSONObject jObj = new JSONObject();
        if (classes.contains(clazz)) {
            return;
        } else {
            classes.add(clazz);
        }
        for(Field f: lof){
            Class parameterizedType = getParameterizedType(f);
            String fieldName = f.getName();
            Type fieldGenericType = f.getGenericType();
            Class<?> fieldType = f.getType();
            if((parameterizedType != null) && !parameterizedType.getName().startsWith("java")){
                addNonStandardField(jObj, fieldName, fieldGenericType.toString(), parameterizedType.getName().toString());
                generateJSON(parameterizedType);
            } else if(!fieldType.isPrimitive() && !fieldType.getName().startsWith("java")){
                addNonStandardField(jObj, fieldName, fieldType.getName().toString(), fieldType.getName().toString());
                generateJSON(fieldType);
            } else{
                addStandardField(jObj, fieldName, fieldGenericType.toString());
            }
        }
        String jsonFileLocation = AnnotatedMethod.pathMash(this.location,clazz.getName() + ".json");
        writeToFile(jObj, jsonFileLocation);
    }

    /**
     * Add a key-value pair to a JSONObject
     * @param jObj
     * @param fieldName
     * @param type
     */
    private void addStandardField(JSONObject jObj, String fieldName, String type) {
        jObj.put(fieldName, type);
    }

    /**
     * Add a key-value pair representing a field of generic type to a JSONObject.
     * For generic classes, the full generic name of the class type is under the key
     * "fullname" while the generic parameter is under "generic".  This is designed for the user to be able
     * to use the "generic" string to locate the JSON file describing the corresponding data type.  This method
     * is used for generics or any class that is not in the standard Java library, in order to establish "links"
     * between the JSON files generated by this plugin.
     * @param jObj
     * @param fieldName
     * @param fullname
     * @param generic
     */
    private void addNonStandardField(JSONObject jObj, String fieldName, String fullname, String generic) {
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("fullname", fullname);
        jsonObject.put("generic", generic);
        jObj.put(fieldName, jsonObject);
    }

    /**
     * Write a JSONObject to a file.
     * @param jsonObject
     * @param location
     */
    private void writeToFile(JSONObject jsonObject, String location) {
        File f = new File(location);
        if (!f.exists()) {
            f.getParentFile().mkdirs();
        } else {
            f.delete();
        }
        try {
            FileWriter file = new FileWriter(location);
            file.write(jsonObject.toJSONString());
            file.flush();
            file.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Get alll fields of a class.
     * @param clazz
     * @return
     */
    private Field[] getAllFields(Class clazz) {
        List<Field> fields = new ArrayList<Field>();
        fields.addAll(Arrays.asList(clazz.getDeclaredFields()));

        if (clazz.getSuperclass() != null) {
            fields.addAll(Arrays.asList(getAllFields(clazz.getSuperclass())));
        }
        return fields.toArray(new Field[] {});
    }

    /**
     * Deternine the parametrized generic type of a class.
     * @param field
     * @return
     */
    public static Class getParameterizedType(Field field) {
        try {
            if (ParameterizedType.class.isAssignableFrom(field.getGenericType().getClass())) {
                ParameterizedType genericType = (ParameterizedType) field.getGenericType();
                return ((Class) (genericType.getActualTypeArguments()[0]));
            } else {
                return (null);
            }
        } catch (ClassCastException e) {
            System.err.println("Error with class casting " + field.getName());
            return (null);
        }
    }
}